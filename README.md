# Project description
Implementation of the algorithm to calculate closest pair of points in a 2-dimensional plane in time O(n*log n) as described by _Algorithm Design by Jon Kleinberg, Eva Tardos_.

Here's an [explanation](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/closepoints.pdf) of the algorithm based on the book. It is a [_divide and conquer_](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) implementation that relies on some geometrical properties.

Implementation is done in different programming languages and using different parallelization techniques:


| Language    | Sequential | Multi-thread | Multi-process |
| ----------- | ----------- | ----------- | -----------   |
| C      | yes       | yes | yes |
| Python   | yes        | no | yes |
| Scala | yes | yes | no |


## Methodology
### Implementation of an oracle
We'll start by implementing the brute-force version of the algorithm: we calculate the distance of each point to all others and take the minimum.

This can be easily implemented and it will be used as [test oracle](https://en.wikipedia.org/wiki/Test_oracle) to prove the correctnes of the _divide and conquer_ implementation.

### Implementation of the sequential version of the algorithm
Next, we implement the algorithm using the _divide and conquer_ technique.

Unit testing is used to verify correctness of basic and edge cases and to guide development. Some of the test cases covered are:

- solution is in the left half
- solution is in the right half
- solution is a pair of points from different halves
- repeat points
- even number of points
- odd number of points


### Property-based testing
Using property-based testing, we compare the results of our algorithm to those generated by the oracle and for multiple inputs randomly generated.

This way we can cover thousands of test cases.

Depending on the language, we use different frameworks to do this testing:

- Scala, [Scalatest](https://www.scalatest.org/user_guide/property_based_testing)
- Python, [hypothesis](https://hypothesis.readthedocs.io/en/latest/)
- C, manual implementation


### Implementation of the parallel version
Depending on the language, we use multi-thread and/or multi-process approach to implement the parallel version of the algorithm.

And again, we can use property-based testing to compare sequential vs parallel versions.

### File-based testing
In order to compare the implementations across languages, we generate a file with random points that is fed to each language to ensure that all compute the same solution.


## Algorithm details
As we said, the algorithm to implement is a _divide and conquer_ recursion that runs in time O(n*log n).

The input is split in two recursively, giving the time O(log n).
The work to do in each iteration is linear, giving the time O(n).

Run time of recursive algorithm = Run time of recursion process * Run time of work done on each step = O(n*log n).

The __key element__ of the algorithm (something that probably is not sufficiently underscored in this  [explanation](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/closepoints.pdf) is to have the points sorted by coordinate _y_. 

The points get sorted before starting the recursive algorithm and they will remain sorted during the recursion as long as we split the input in a specific way. Basically, we need to keep two arrays of points, each of them sorted by a different coordinate, _x_ and _y_. Furthermore, the points sorted by coordinate _y_ will need to keep a reference to their position in the array sorted by _x_. And that's all, with that in mind, it should be easy to understand the implementation. 

Of course, we need to use a sorting algorithm that runs in O(n*log n) like [mergesort](https://en.wikipedia.org/wiki/Merge_sort)

### Notation and terminology

The notation (variable names) used in the implementation is the one used in _Algorithm Design by Jon Kleinberg, Eva Tardos_.

Although those names may not comply with the rules to name objects in each of the languages used,
keeping the same notation across the board makes it easy to understand the code.

- P = array of points
- Px, Py = array of points sorted by coordinates _x_ and _y_ respectively
- Qx, Qy = left half part of P sorted by coordinates _x_ and _y_ respectively
- Rx, Ry = right half part of P sorted by coordinates _x_ and _y_ respectively



## Favourite picks

### Functional implementation of the brute-force algorithm